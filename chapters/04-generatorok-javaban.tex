\chapter{Generátorok \textit{Java}ban}

Az előző fejezetek bevezették a szükséges alapfogalmakat, melyekkel a generátorokat előállító módszer dolgozik. Ebben a fejezetben a dolgozat eredményét jelentő eljárás kerül részletesen ismertetésre.

Az elméleti háttér és az implementáció szorosan összefonódik, így a kettő párhuzamosan, egymásra támaszkodva jelenik meg. Az eljárást lépésenként, a kód végrehajtását követve mutatom be, rávilágítva az egyes döntések mögötti megfontolásokra. Kiindulva a módosítatlan forráskódból, a fejezet egy működő generátor létrehozásánál ér véget, megágyazva ezzel a példákat bemutató következő résznek.

\section{Annotáció-feldolgozás}

A transzformációs eljárás a nyelv és a fordító módosítása nélkül működik. Viszont valamilyen módon a forráskódban jeleznie kell a programozónak, hogy egy metódusból generátormetódust szeretne készíteni. Erre biztosítanak lehetőséget az \textit{annotációk}. Az annotáció egy olyan, programkonstrukcióra vonatkozó metaadat, melynek nincs közvetlen hatása a programvégrehajtásra \cite{JLS8}.

Az annotáció fogalmát a \textit{JSR 175} specifikáció vezette be, és megjelenése óta több közkedvelt programkönytárban is bizonyította sokoldalúságát. Emiatt természetes döntés volt, hogy a generátormetódusokat is egy annotációval kell megjelölni, ez a \texttt{@Generator}.

Az annotációk feldolgozását a \textit{JSR 269} által leírt \textit{Pluggable Annotation Processing API} részét képező \texttt{javax.annotation.processing.Processor} interfészt megvalósító osztályok végezhetik. Javasolt azonban ennek egy absztrakt megvalósítását, az ugyanabban a csomagban található \texttt{AbstractProcessor} osztályt használni ősosztályként. A \textit{Java} fordító (továbbiakban \texttt{javac}) alapértelmezés szerint a \texttt{classpath}-ban keres feldolgozókat, mely viselkedés felülbírálható a \texttt{processorpath} és \texttt{processor} parancssori kapcsolók révén \cite{JavacOptions}.

\subsection{Transzformálandó metódusok összegyűjtése}

A \texttt{Processor} interfész \texttt{process(Set<? extends TypeElement>, RoundEnvironment)} metódusának implementálásával lehet a tényleges feldolgozást elvégezni. A \texttt{javac} a fordítást több körben végzi, és az említett metódust az előző körben előállított gyökérelemekkel hívja meg. Erre a több körös fordításra azért van szükség, mert a feldolgozók az annotációk és az annotációk által megjelölt elemek alapján forráskódot generálhatnak. A gyökérelem általában egy fordítási egység (\textit{compilation unit}), mely több osztályt és interfészt foglalhat magában.

A feldolgozók jelezhetik, hogy mely annotációk feldolgozását képesek elvégezni, azonban a \textit{"*"} értéket megadva, az összes, előző körben generált gyökérelem átadásra kerül a feldolgozó részére. Az implementáció részét képező \texttt{jield.apt.JieldProcessor} osztály is ezt a lehetőséget használja ki. A gyökérelemektől elindulva megkeresi az összes osztály- és interfész-deklarációt, majd ezeket megvizsgálva összegyűjti a \texttt{@Generator} annotációval ellátott metódusokat.

Az e módon összegyűjtött metódusok azonban nem biztos, hogy eleget tesznek a transzformáció követelményeinek. Egy metódus akkor transzformálható, ha a következő kritériumoknak megfelel:

\begin{itemize}
    \item A visszatérési értékének típusa \texttt{java.util.stream.Stream}.
    \item Van implementációja, azaz ha a tartalmazó típusa absztrakt osztály, akkor nem rendelkezik az \texttt{abstract} módosítóval, míg ha egy interfészben foglal helyet, akkor el van látva a \texttt{default} módosítóval.
\end{itemize}

Ha a \texttt{@Generator} annotáció egy olyan metóduson van elhelyezve, mely megsérti a fenti követelményeket, akkor a transzformációs és vele együtt a fordítási folyamat is hibával leáll.

\section{Befoglaló osztály létrehozása}

A transzformálandó metódusok birtokában következhet a generátorok létrehozása. Minden egyes generátorhoz létrejön egy osztály, mely a transzformáció folyamán előállított metódusok és mezők összegyűjtésére és egységbe zárására szolgál. Valójában ez az osztály csak az eljárás későbbi lépéseiben jön létre, azonban érdemes korábban megemlíteni, pont az előző szerepe miatt.

A befoglaló osztály előállítására több út is kínálkozik, melyek alapvetően azzal vannak kapcsolatban, hogy az osztályt egy új fordítási egységben kívánjuk elhelyezni, vagy pedig ugyanabban a fordítási egységben, melyben a generátormetódus is szerepel. Az utóbbi eset jelentheti belső osztály (\textit{inner class}), statikus kontextusban (\textit{static context}) beágyazott osztály (\textit{nested class}), esetleg a metódustörzsben helyet kapó lokális vagy névtelen (\textit{anonymous}) osztály létrehozását. Ezek közül csak a belső osztály lesz vizsgálat tárgya, hiszen egyfelől ezt alkalmazza az implementáció, másfelől nem különbözik lényegesen a többi lehetőségtől.

\subsection{Belső osztály (\textit{inner class})}

A belső osztály egy másik osztályban helyet kapó olyan tagosztály, mely hozzáfér a befoglaló osztály példányváltozóihoz. Mi több, a befoglaló osztályt tartalmazó osztályhierarchia minden elemének példányváltozóit hivatkozhatjuk belőle. Ennek köszönhetően a belső osztály tökéletes választás a példánymetódusok transzformálásához.

Érdemes még egyszer hangsúlyozni, hogy a belső osztály elhelyezéséhez a fordító által az eredeti forráskódból felépített absztrakt szintaxisfát (\textit{AST}) közvetlenül módosítani kell. Nem létezik azonban jól dokumentált, publikus \textit{API} a \texttt{javac} készítette szintaxisfa megváltoztatására, kiegészítésére. Az ezt az utat járó megoldások kizárólag a hivatalosan nem támogatott \texttt{com.sun.tools.javac.tree} csomag osztályaira támaszkodhatnak. A csomag dokumentációja tartalmazza is a következő figyelmeztetést:

\begin{quote}
	\textit{This is NOT part of any supported API. If you write code that depends on this, you do so at your own risk. This code and its internal interfaces are subject to change or deletion without notice.}
\end{quote}

Ennek következtében a szintaxisfa közvetlen módosítása nem javallott, az ilyen módon előállított forráskód működése sem garantált. Azonban a fordító is az említett \textit{API}-t használja, ami biztosítékot jelent tetszőleges kód előállítására.

A belső osztályt a nevében is szereplő belső volta miatt érdemes használni. Pontosan ugyanazokhoz a mezőkhöz, metódusokhoz és típusokhoz fér hozzá, amelyekhez a \texttt{@Generator} annotációval ellátott metódus is. Ez a \texttt{private} láthatóságú deklarációkat is magában foglalja, amit egy másik fordítási egységben elhelyezkedő kód még akkor sem lát, ha azonos csomagban található. 

Összefoglalva, a megoldás előnye, hogy az előállított osztály ugyanazokhoz a deklarációkhoz fér hozzá, mint az eredeti függvény. Hátránya azonban, hogy egy nem támogatott \textit{API}-t alkalmaz, mely nem is kifejezetten ilyen jellegű felhasználásra készült. Emellett az annotáció-feldolgozás sem meglevő forráskód módosítását, hanem új forráskód generálását célozza.

\subsection{Félnyilvános (\textit{package private}) osztály}

Ez a megoldás egy új fordítási egységben, de azonos csomagban elhelyezett osztály létrehozását jelenti, mely félnyilvános láthatósággal bír. Ilyen osztály generálása gond nélkül kivitelezhető, hiszen ebben az esetben az osztály létrehozásához nem kell a már létező szintaxisfát módosítani, hanem mindössze szöveges forráskódot kell összeállítanunk. Ezt a \texttt{javac} a többkörös fordítási folyamatba illesztve ugyanazon a módon lefordítja, mint azokat forrásfájlokat, melyekkel eredetileg meghívtuk.

Forráskódot összeállíthatunk karaktersorozatok konkatenációjával is, azonban ez kifejezetten fáradságos. Helyette érdemes valamilyen létező megoldást alkalmazni, például a \textit{javapoet} könyvtárat, melynek segítségével tetszőleges \textit{Java} forráskód előállítható, akár parametrizált módon.

Bár a kényelmes forráskód-generálás vonzó alternatívát jelent, ebben az esetben akadályokba ütközhet, hogy az újonnan létrehozott osztály hozzáférjen mindazokhoz a mezőkhöz és metódusokhoz, melyekhez az eredeti metódus is hozzáfért. Ez a probléma azért állhat fent, mert egy metódus hozzáfér a tartalmazó osztály és a teljes befoglaló osztályhierarchia minden deklarációjához, beleértve a \texttt{private} láthatóságúakat is, míg egy független, nem-belső osztály nem. Az ilyen láthatóságú elemek használatának korlátozása azonban komoly megkötés lenne a felhasználók számára. Tehát nem kerülhető el ennek a problémának a megoldása.

A különböző utak részletes kifejtése nélkül ki lehet azonban jelenteni, hogy a láthatóság (vagyis annak hiánya) által okozott kérdések megválaszolása óriási erőfeszítéseket igényel. Vagy bonyolult kerülőutakat kell alkalmazni, hogy a megfelelő deklarációk elérhetőek legyenek, vagy pedig \textit{reflection}t kell használni, mely összetett és fáradságos megoldás.

Bár az osztály létrehozását kivitelezhető a meglevő szintaxisfa módosítása nélkül, azonban ahhoz hogy az eredeti metódus generátormetódussá váljon, tehát az újonnan előállított osztály metódusait hívja, szükséges a felépített szintaxisfa átírása. Hiába generálunk tehát egy új fordítási egységet, a létező szintaxisfát mindenképpen meg kell változtatnunk.

A félnyilvános, új fordítási egységbe leképezett osztály mellett szól a stabil és kényelmes \textit{API}, amivel generálható, és hogy az annotáció-feldolgozás kifejezetten ezt támogatja. Ellenérvként említendő, hogy csak bonyolultan kivitelezhető, hogy minden, az eredeti metódus által használt deklaráció elérhető legyen. Emellett semmilyen módon nem kerülhető el az eredeti metódus módosítása.

\subsection{A választott megoldás}

A felsorolt hátrányai ellenére, az implementáció a szintaxisfa közvetlen módosításával egy belső osztályt generál. Bár a félnyilvános osztály is alkalmas lenne speciális esetekre, ennek ellenére túl gyakran fordulhat elő olyan eset, amikor egy generátormetódus a tartalmazó osztály vagy osztályhierarchia egy \texttt{private} láthatósággal rendelkező deklarációját kívánja használni, és emiatt nem, vagy csak nehézkesen tudnánk a transzformációt alkalmazni.

A \texttt{com.sun.tools.javac.tree} csomag használatára példa a \textit{Lombok} könyvtár. Ennek forráskódja azonban alacsony színvonalon (és hiányosan) dokumentált, emellett az eredeti \textit{API}-t becsomagolva használja, így nem triviális az \textit{API}-hívások pontos visszakövetése.

\section{A metódus vágása}

A transzformáció legjelentősebb része a \texttt{@Generator} annotációval ellátott metódusok implementációjának szétvágása. Ahogy a generátor, mint félkorutin ismertetésénél is említésre került, egy generátor futása egy érték visszaadásakor felfüggesztődik, majd legközelebb innen folytatódik. Ez viselkedés csak úgy valósítható meg, hogy az eredeti metódust sok kisebb metódusra bontjuk.

Ez tehát az alapelv, ami a transzformáció mögött áll. A metódus darabokra bontását úgynevezett vágási pontoknál végezzük. Transzformációs szempontból a \textit{vágási pont} a jobb elnevezés, viselkedés szempontjából azonban mint \textit{felfüggesztési pont} tekinthetünk rájuk. Ezek lesznek azok a pontok, ahol a generátor működése felfüggesztésre kerül, és valamilyen módon meg kell őrizni, hogy melyik darab végrehajtásával kell folytatni a működést. Korántsem magától értetődő azonban a vágást úgy elvégezni, hogy a kód értelme ne változzon. Tekintettel kell lenni a vezérlési szerkezetekre, az ugrást megvalósító \texttt{break} és \texttt{continue} utasításokra, valamint a lokális változók hatókörére is.

A vágásnál lesz alkalmazható a \textit{CPS}, mely alkalmas a vágás során keletkező metódusokon átívelő vezérlési szerkezetek megvalósítására. A \textit{CPS}-transzformáció két formában, egyszer fordítási, egyszer pedig futási időben jelenik meg. A fordítási idejű \textit{CPS} azt jelenti, hogy a bemutatott eljárás folyamatosan nyilvántartja, hogy milyen \textit{continaution}ök állnak rendelkezésre, mikor melyik darab jelenti a \textit{continuation}t. Futási időben a \textit{CPS} úgy jelenik meg, hogy mindegyik metódus rendelkezik egy \textit{continuation} paraméterrel, ez azonban szinte formális jellegű, hiszen a \textit{continuation}ök kijelölése fordítási időben dől el.

Kiindulási alapot szolgáltatott Insa és Silva \citeyear{IterToRec} módszere, mely a \textit{Java} által biztosított ciklusok rekurzióba történő átírását valósítja meg. Ez kétféle szempontból is szükséges. Egyrészt a \textit{CPS} csak rekurzióval alkalmazható, másrészt csak így lehet egy ciklust darabokra bontani. Az itt bemutatott megoldás azonban több ponton is eltér az általuk ismertetett eljárástól, hogy jobban megfeleljen a generátorok követelményeinek. Az általam készített eljárás teljesen eltérő módon képez metódusokat a ciklusokból, paraméterek helyett osztályszintű mezőkbe emeli ki a lokális változókat (átnevezéssel párosítva, ahol indokolt), és egyelőre nem támogatja a \texttt{try-catch} szerkezetet.

\subsection{A \textit{return} új szerepe}

Más nyelvek általában bevezetnek egy új kulcsszót (ez legtöbbször a \texttt{yield}) a generátorokból való visszatérésre. Sajnos erre \textit{Java}ban csak akkor lenne lehetőség, ha a nyelvet és vele együtt a fordítót módosítanánk. Emiatt egy már létező kulcsszónak kell új értelmet adni. Kézenfekvő és valójában egyetlen használható megoldást jelent a \texttt{return}. Ez lesz tehát az az utasítás, mellyel visszatérhetnek a generátorok.

Az, hogy a generátorból a \texttt{return} utasítást használva adható vissza érték, azt is jelenti, hogy egy \texttt{return} egyben explicit vágási pont is lesz. Egy \texttt{return} után ugyanis mindenképpen vágni kell, mivel a generátor futásának legközelebb a következő utasítással kell folytatódnia. Implicit vágási pontok a vezérlési szerkezeteknél fordulnak elő, ezek figyelembe vétele a különböző szerkezetek transzformációjánál szükséges. Mind az explicit, mind az implicit vágási pontok új metódust fognak eredményezni.

\begin{lstlisting}[language=Java, caption={Az $1, 2$ sorozatot előállító generátor}, captionpos=b, label=JavaSimpleGen, escapechar=$]
@Generator
Stream<Integer> generate() {
    return 1;
    return 2;
}
\end{lstlisting}

A \ref{JavaSimpleGen} kódrészlet metódusa az $1, 2$ sorozatot generálja. Ahhoz, hogy a transzformáció után előállított kód a generátorokra jellemző felfüggeszthető és folytatható viselkedéssel rendelkezzen, a két \texttt{return} (lényegében \texttt{yield}) között szét kell vágni a metódustörzset, hogy a második \texttt{return} az elsőtől függetlenül végrehajtható legyen.

\subsection{Parciális transzformáció}

Az előző fejezetben a \textit{CPS}-transzformáció során az összes függvényt és hívást egy szabályrendszernek megfelelően kellett átalakítani. A generátorok előállításához azonban nem szükséges a teljes kódrészlet ilyen stílusúra hozása, mi több, nem is lehetséges. Ehhez ugyanis a metódustörzsben meghívott összes függvényt transzformálni kellene, vagy legalább olyan metódusba csomagolni, mely \textit{CPS}-ben hívható. Emiatt az eljárás a metódushívásokat nem módosítja, a \textit{CPS} csak a vezérlési szerkezeteknél kerül alkalmazásra.

Nem szükséges azonban a programvezérlésre hatással levő minden struktúra bevonása a transzformációba. Csak azokat kell szétvágni, a generátor-viselkedést megvalósítandó, melyek tartalmaznak explicit vágási pontot, azaz \texttt{return} utasítást. Ennek hiányában az adott szerkezet módosítás nélkül átemelhető az eredeti metódusból. Ekképpen az utasításoknak csak egy parciális transzformációjára kerül sor, mindössze azokat a szerkezeteket érintve, melyek vágása elkerülhetetlen.

\section{A vezérlés transzformációja}

A metódus felbontásának hátterét ismerve következhet az egyes vezérlési szerkezetek átalakításának bemutatása. A \texttt{try-catch} kivételével ez az összes, \textit{Java}ban használható eszközt jelenti. A transzformált vezérlési struktúrák egyfajta építőkövek lesznek, melyekből a generátor felépíthető. Szükséges még a létrejött darabok összekapcsolása, ezt a feladatot egy speciális \textit{trampoline} fogja ellátni. A különböző szerkezetek átformálását szemlélető sematikus kódrészleteket még megelőzi a használt jelölés- és típusrendszer bemutatása.

\subsection{Típusok és jelölések}

\subsubsection{Dobozok}

Az átalakítás szempontjából fontos szerepet játszó utasításokat vagy kifejezéseket lekerekített sarkú dobozok jelképezik. Ezek közül a ``\textit{Kódrészlet}'' felirattal rendelkezők érdemelnek külön említést, melyek mindig olyan utasítássorozat helyén állnak, mely \textit{nem} tartalmaz \texttt{return} utasítást. A többi doboz szerepe vagy tartalma a feliratnak megfelelő.

\subsubsection{\texttt{GeneratorState<T>}}

Az eljárás eredményeként létrehozott metódusok mindegyike egyetlen formális paraméterrel rendelkezik, ez a \textit{continuation}. Ennek típusa \texttt{GeneratorState<T>}, mely egy állapotot jelképez, amiben a generátor lehet. A típus egy funkcionális interfész, és a transzformáció által képzett metódusok mindegyike megvalósítja. A \texttt{T} típusparaméter azt a típust jelöli, amelynek példányait a generátor előállítja.

\begin{lstlisting}[language=Java, caption={A \texttt{GeneratorState<T>} interfész}, captionpos=b, label=JavaGenState, escapechar=$]
@FunctionalInterface
public interface GeneratorState<T> extends Function<GeneratorState<T>, Bounce<T>> {
    static <T> GeneratorState<T> empty() { 
      return null; 
    }
}
\end{lstlisting}

A \ref{JavaGenState} kódrészletből látható, hogy a \texttt{GeneratorState} igazából nem más, mint egy \textit{alias}, olyan metódusok számára, melyek egyetlen paramétere \texttt{GeneratorState}, visszatérési értéke pedig \texttt{Bounce} típusú.

\subsubsection{\texttt{Bounce<T>}}

A vágás során képzett metódusok visszatérési típusa lesz \texttt{Bounce<T>}. A névből sejthető, hogy a típus a \textit{trampolining} technikával lesz kapcsolatban, s ez valóban így is van. A metódusok e típus példányainak formájában visszadják a \textit{trampoline} részére a következőnek végrehajtandó metódust (ha van ilyen), valamint egy, az aktuális állapot által generált értéket (ha van ilyen). Ezek az értékek az eredeti, \texttt{@Generator} annotációval ellátott metódus \texttt{return} utasításai után álló kifejezésekből származnak. A \texttt{T} típusparaméter szerepe azonos, mint a \texttt{GeneratorState} esetén.

\begin{lstlisting}[language=Java, caption={A \texttt{Bounce<T>} osztály legfontosabb mezői és metódusai}, captionpos=b, label=JavaBounce, escapechar=$]
public final class Bounce<T> {
    private final Optional<Thunk<Bounce<T>>> continuation;

    private final Optional<T> value;

    public static <T> Bounce<T> cont(Thunk<Bounce<T>> continuation, T value) {
        return new Bounce<>(continuation, value);
    }

    public static <T> Bounce<T> cont(Thunk<Bounce<T>> continuation) {
        return new Bounce<>(continuation, null);
    }

    /* további metódusok... */
}
\end{lstlisting}    

Az osztály példányait csak úgynevezett \textit{static factory} metódusok útján lehet létrehozni. Ezek használatával jobban olvasható kódot kapunk (bár ez generált kód esetén annyira nem szempont). A \textit{continuation} mező értéke egy opcionális számítás, melyet a \textit{trampoline}-nak következőnek meg kell hívnia. A \textit{value} mező egy opcionális generált elemet tárol. 

\subsection{Állapotok és \textit{trampolining}}

Az eljárás által előállított generátorok motorja egy \textit{trampoline}, mely alapvetően az állapotokat jelképező metódusok meghívásáért felelős. Viszont rendelkezik egy legalább ilyen fontos, másodlagos feladattal is. A legutóbb végrehajtott metódus minden esetben egy \texttt{Bounce<T>} típusú objektumot ad vissza. Ezen objektum vizsgálata után a \textit{trampoline} a következő döntések egyikét hozza:

\begin{itemize}
    \item Ha van \textit{continuation}, amit legközelebb meg lehet hívni, és nincsen generált érték, akkor meghívja a \textit{continuation}t. Ilyen esetekben a legutoljára végrehajtott metódus egy áthidaló állapot volt, mint például egy transzformált \texttt{for} ciklus inicializását végző állapot, mely nem állít elő semmilyen értéket.
    \item Ha \textit{continuation} és generált érték is rendelkezésre áll, akkor a generátor futása felfüggesztésre kerül. A \textit{trampoline} elmenti a \textit{continuation}t, és visszaadja a generált elemet.
    \item Ha nincs \textit{continuation}, akkor a generátor már nem képes több elem generálására, futása véget ért. Ha volt generált érték, akkor az még visszaadásra kerül.
\end{itemize}

Ez lesz az a mechanizmus, ami a generátort hajtja, és a metódusok közötti átmenetet biztosítja.

\subsection{Lineáris kód}

A lineáris kód egy olyan utasítássorozat, amiben nem szerepel semmilyen elágazás. Kakukktojás a többi vezérlési szerkezettel összevetve, fontos azonban megemlíteni, hiszen egyfajta alapesetnek tekinthető.

\begin{center}
\begin{mdframed}
\begin{minipage}[t]{0.4\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#1}; \vspace*{0.5cm} @ 
return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#1}; \vspace*{0.3cm} @
@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#2}; \vspace*{0.5cm} @ 
return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#2}; \vspace*{0.3cm} @
\end{lstlisting}
\end{minipage} 
\begin{minipage}[t]{0.6\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
Bounce<T> method1(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#1}; \vspace*{0.3cm} @
  return cont(() -> method2(k), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#1}; \vspace*{0.2cm} \hspace*{1.75cm} @);
}

Bounce<T> method2(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#2}; \vspace*{0.3cm} @
  return cont(() -> k.apply(null), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.2cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#2}; \vspace*{0.2cm} \hspace*{1.6cm} @);
}
\end{lstlisting} 
\end{minipage}
\end{mdframed}
\captionof{lstlisting}{Lineáris vezérlésű kód transzformálása}
\label{GenLinear}
\end{center}

A \ref{GenLinear} kódrészlet jobboldala két \texttt{return} utasítást tartalmaz, melyek a kódrészlet két darabba vágását eredményezik. A \texttt{method1} az első \texttt{return} előtt álló utasításokat tartalmazza, valamint az első generált értéket előállító kifejezést. Emellett jelzi a \textit{trampoline} számára, hogy a futásnak legközelebb a \texttt{method2}-vel kell folytatódnia. A \texttt{method2} tartalmazza a még hátralevő kódrészletet, valamint előállítja a második generált értéket. 

Érdemes megfigyelni, hogy mivel ez az utolsó \textit{állapot}, a \textit{trampoline}-nak már közvetlenül a kapott \textit{continuation}t meghívó lambda függvényt ad át, jelezve a számítás végét. Ez a többi vezérlési szerkezet esetén is hasonlóan fog történni.

\subsection{\texttt{if-else}}

\begin{center}
\begin{mdframed}
\begin{minipage}[t]{0.4\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
if (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \hspace*{1.04cm} \vspace*{0.3cm} @) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#1}; \vspace*{0.5cm} @ 
  return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#1}; \vspace*{0.3cm} @
} else {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#2}; \vspace*{0.5cm} @ 
  return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#2}; \vspace*{0.3cm} @
}
\end{lstlisting}
\end{minipage} 
\begin{minipage}[t]{0.6\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
Bounce<T> method1(GeneratorState<T> k) {
  if (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \hspace*{1.04cm} @) {
    return cont(() -> method2(k));
  } else {
    return cont(() -> method3(k));
  }
}

Bounce<T> method2(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#1}; \vspace*{0.3cm} @
  return cont(() -> k.apply(null), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#1}; \vspace*{0.2cm} \hspace*{1.75cm} @);
}

Bounce<T> method3(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#2}; \vspace*{0.3cm} @
  return cont(() -> k.apply(null), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.2cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#2}; \vspace*{0.2cm} \hspace*{1.6cm} @);
}
\end{lstlisting} 
\end{minipage}
\end{mdframed}
\captionof{lstlisting}{\texttt{if-else} transzformálása}
\label{GenIfElse}
\end{center}

Az \texttt{if-else} transzformációjának eredményeként megjelenik egy olyan metódus, mely nem ad vissza generált értéket, mindössze azt mondja meg a \textit{trampoline}-nak, hogy a \texttt{then} vagy pedig az \texttt{else} ággal folytatódjon a végrehajtás.

Erre azért van szükség, mert az egyes ágakon belül akár több \texttt{return} is lehet, amelyek mindegyike egy vágási pont lesz. Ezek hatására a megfelelő ágba történő belépés után fel kell tudni függeszteni a generátor végrehajtását. Újabb hívások esetén természetesen onnan kell folytatni a futást, ahol az abbamaradt, ami együtt jár azzal, hogy maradni kell ugyanabban az ágban, amelyet eredetileg választottunk, anélkül, hogy a feltételt újra kiértékelnénk. Ez a működés úgy biztosítható, ha bevezetésre kerül egy olyan állapot, melynek egyetlen feladata a futás irányának kijelölése, a \ref{GenIfElse} kórészletben ez a \texttt{method1}.

\pagebreak

\subsection{\texttt{for} ciklus}

Talán a legösszetettebb kimenettel a \texttt{for} ciklus átalakításának folyamata rendelkezik. Ezt az okozza, hogy a ciklus fejében a programozó egy inicializáló, egy, az iterációra vonatkozó feltételt meghatározó és egy frissítő részt adhat meg. További komplexitást jelentenek a \texttt{continue} és \texttt{break} utasítások, melyektől egyelőre eltekintünk.

\begin{center}
\begin{mdframed}[topline=true]
\begin{minipage}[t]{0.4\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
for (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Init}; \hspace*{0.6cm}@; @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.2cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \hspace*{1.0cm}@; @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.2cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Frissít}; \vspace*{0.3cm} \hspace*{0.9cm}@) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.5cm} @ 
  return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.3cm} @
}
\end{lstlisting}
\end{minipage} 
\begin{minipage}[t]{0.6\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
Bounce<T> method1(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Init}; \vspace*{0.3cm} @
  return cont(() -> method2(k));
}

Bounce<T> method2(GeneratorState<T> k) {
  if (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \hspace*{1.04cm} @) {
    return cont(() -> method3(k));
  }
  return cont(() -> k.apply(null));
}

Bounce<T> method3(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.3cm} @
  return cont(() -> method4(k), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.2cm} \hspace*{1.2cm} @);
}

Bounce<T> method4(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Frissít}; \vspace*{0.3cm} @
  return cont(() -> method2(k));
}
\end{lstlisting} 
\end{minipage}
\end{mdframed}
\captionof{lstlisting}{\texttt{for} ciklus transzformálása}
\label{GenFor}
\end{center}

Vegyük sorra, hogy a vezérlés hogyan fog végighaladni a létrehozott metódusokon! Értelemszerűen az átalakított kódban is először (és pontosan egy alkalommal) az inicializáló részt kell végrehajtani, amit az \textit{Init} doboz szimbolizál. Ezt követi egy olyan állapot, mely a ciklusfeltételnek felel meg. A generátor magjából képzett állapotok csak akkor lesznek lefuttatva, ha a feltétel teljesül. A végrehajtás irányának ilyen módon történő kiválasztása hasonlít az \texttt{if-else} esetében látotthoz. A ciklusmag és annak részeként az eredeti kódrészlet egyetlen \texttt{return} utasítása által visszaadott kifejezés a \texttt{method3}-ba kerül. Mivel csak ez a metódus ad vissza generált értéket, csak ennek a végrehajtását követően fog a generátor futása felfüggesztésre kerülni. 

A generátor következő meghívásakor a futás a \textit{Frissít} dobozt tartalmazó metódussal folytatódik. Ez a metódus lesz az, ami a transzformált kódrészletet valóban ciklussá teszi. Ugyanis a metódus ismét a \texttt{method2} meghívását kéri a \textit{trampoline}-tól, ami maga a feltétel. Ha a feltétel teljesül, akkor újra a ciklusmag következik, ami újabb megállást, majd esetleg újabb folytatást is jelent. És ez mindaddig folytatódik, amíg a feltétel teljesül, ugyanúgy, mint egy \texttt{for} ciklus esetén.

Nem lehet eléggé kihangsúlyozni, hogy a transzformált kódban a vezérlés útja teljesen explicitté vált. Mindig pontosan kiolvasható, hogy melyik állapot fog következni, mit fog legközelebb a generátor végrehajtani, milyen értéket fog legközelebb képezni.

\subsection{\texttt{foreach} ciklus}

A \texttt{foreach} ciklus egy tömb vagy egy \texttt{Iterable} elemein való iterálást tesz lehetővé. Transzformálását tekintve hasonlít a \texttt{for} ciklushoz, frisssítő metódusra azonban nincsen szükség.

\begin{center}
\begin{mdframed}[topline=true]
\begin{minipage}[t]{0.4\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
for (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Változó}; \hspace*{1.05cm}@ : @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.2cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Forrás}; \vspace*{0.3cm} \hspace*{0.9cm}@) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.5cm} @ 
  return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.3cm} @
}
\end{lstlisting}
\end{minipage} 
\begin{minipage}[t]{0.6\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
Bounce<T> method1(GeneratorState<T> k) { @\vspace{0.2cm}@
  iterator = CPSUtil.iterator(@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, yshift=0.1cm, inner sep=5pt, anchor=west] {Forrás}; \vspace{0.3cm} \hspace*{1.0cm}@);
  return cont(() -> method2(k));
}

Bounce<T> method2(GeneratorState<T> k) {
  if (iterator.hasNext()) { @\vspace{0.2cm}@
    @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Változó}; \vspace*{0.2cm} \hspace*{1.1cm}@ = iterator.next();
    return cont(() -> method3(k));
  }
  return cont(() -> k.apply(null));
}

Bounce<T> method3(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.3cm} @
  return cont(() -> method2(k), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.2cm} \hspace*{1.2cm} @);
}
\end{lstlisting} 
\end{minipage}
\end{mdframed}
\captionof{lstlisting}{\texttt{foreach} ciklus transzformálása}
\end{center}

Elsőnek egy inicializáló állapot jön létre, mely kinyer a \textit{Forrásból} egy \texttt{Iterator} objektumot. A \texttt{CPSUtil.iterator(Iterable)} metódus csak ennek az egységesítésére szolgál, elfedve, hogy tömbről vagy pedig \texttt{Iterable} objektumról van szó. 

A feltétel az \texttt{iterator.hasNext()} kifejezés lesz, amely ha teljesül, akkor előállítjuk a következő elemet, és következhet a ciklusmag végrehajtása. Ismét a magból képzett metódus fog csak generált értéket visszaadni, így csak ezt követően kerülhet felfüggesztésre a futás. A mag végrehajtása után újra a feltételt jelképező metódus következik, és ez így folytatódik mindaddig, míg az iterátort ki nem merítettük.

\subsection{\texttt{while} és \texttt{do-while} ciklus}

A \texttt{while} és \texttt{do-while} ciklus hasonlóan működik, mindössze a minimális ismétlések számában különböznek, így a transzformációjuk sem tér el jelentősen.

\begin{center}
\begin{mdframed}[topline=true]
\begin{minipage}[t]{0.4\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
while (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \vspace*{0.3cm} \hspace*{1.14cm}@) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.5cm} @ 
  return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.3cm} @
}
\end{lstlisting}
\end{minipage} 
\begin{minipage}[t]{0.6\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true, aboveskip=1em]
Bounce<T> method1(GeneratorState<T> k) {
  if (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \hspace*{1.04cm} @) {
    return cont(() -> method2(k));
  }
  return cont(() -> k.apply(null));
}

Bounce<T> method2(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.3cm} @
  return cont(() -> method1(k), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.2cm} \hspace*{1.2cm} @);
}
\end{lstlisting} 
\end{minipage}
\end{mdframed}
\captionof{lstlisting}{\texttt{while} ciklus transzformálása}
\label{GenWhile}
\end{center}

A \ref{GenWhile} kódrészletben két generált metódus jelenik meg. A \texttt{method1} végzi a ciklusfeltétel ellenőrzését. Amennyiben ez teljesül, a generátor futása folytatódik a törzset jelképező \texttt{method2}-vel, mely már értéket is állít elő.   
\begin{center}
\begin{mdframed}[topline=true]
\begin{minipage}[t]{0.4\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true, aboveskip=1em]
do {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.5cm} @ 
  return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.3cm} @
} while (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \vspace*{0.3cm} \hspace*{1.14cm}@);
\end{lstlisting}
\end{minipage} 
\begin{minipage}[t]{0.6\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
Bounce<T> method1(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet}; \vspace*{0.3cm} @
  return cont(() -> method2(k), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés}; \vspace*{0.2cm} \hspace*{1.2cm} @);
}

Bounce<T> method2(GeneratorState<T> k) {
  if (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Feltétel}; \hspace*{1.04cm} @) {
    return cont(() -> method1(k));
  }
  return cont(() -> k.apply(null));
}
\end{lstlisting} 
\end{minipage}
\end{mdframed}
\captionof{lstlisting}{\texttt{do-while} ciklus transzformálása}
\end{center}

A \texttt{do-while} ciklus átalakításával nyert kód pontosan ugyanazokat a metódusokat tartalmazza, mint \texttt{while} esetében, csak megcserélt sorrendben. Elsőnek a magot hajtja végre a generátor, és csak utána következik a feltétel, egy megállást követően.

\subsection{\texttt{switch}}

\begin{center}
\begin{mdframed}[topline=true]
\begin{minipage}[t]{0.4\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
switch (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Szelektor}; \vspace*{0.3cm} \hspace*{1.35cm}@) {
  case @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Konstans}; \vspace*{0.3cm} \hspace*{1.35cm}@:
    @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#1}; \vspace*{0.5cm} @ 
    return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#1}; \vspace*{0.3cm} @

  default :
    @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#2}; \vspace*{0.5cm} @ 
    return @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#2}; \vspace*{0.3cm} @
}
\end{lstlisting}
\end{minipage} 
\begin{minipage}[t]{0.6\textwidth}
\begin{lstlisting}[language=Java, numbers=none, breaklines=true]
Bounce<T> method1(GeneratorState<T> k) { @\vspace{0.2cm}@
  switch (@ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Szelektor}; \vspace*{0.3cm} \hspace*{1.35cm}@) {
    case @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Konstans}; \vspace*{0.1cm} \hspace*{1.35cm}@:
      return cont(() -> method2(k));

    default :
      return cont(() -> method3(k));
  }
}

Bounce<T> method2(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#1}; \vspace*{0.3cm} @
  return cont(() -> method4(k), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#1}; \vspace*{0.2cm} \hspace*{1.75cm} @);
}

Bounce<T> method3(GeneratorState<T> k) {
  @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west] {Kódrészlet \#2}; \vspace*{0.3cm} @
  return cont(() -> method4(k), @ \tikz[remember picture, overlay]\node[rounded corners, draw, xshift=-0.1cm, inner sep=5pt, anchor=west, yshift=0.1cm] {Kifejezés \#2}; \vspace*{0.2cm} \hspace*{1.75cm} @);
}

Bounce<T> method4(GeneratorState<T> k) {
  return cont(() -> k.apply(null));
}
\end{lstlisting} 
\end{minipage}
\end{mdframed}
\captionof{lstlisting}{\texttt{switch} utasítás transzformálása}
\end{center}

A transzformáció megtartja a \texttt{switch} utasítást, hiszen továbbra is több konstans közül kell választani a szelektor értéke alapján. Azonban, hogy a futás felfüggeszthető és folytatható legyen, minden egyes \texttt{case}-hez tartozó utasítássorozat egy új metódusba kerül. Ez akkor is megtörténik, ha nem \texttt{return}, hanem a jellemzőbb \texttt{break} utasítással ér véget utasítások egy sorozata.

A \texttt{switch} ágaiból képzett metódusok már csak az adott ághoz tartozó utasításokat tartalmazzák. Egy további állapotban történik a vezérlés újraegyesítése, mely semmilyen, az eredeti kódrészletből átemelt utasítást nem tartalmaz.

\subsection{Fordítási idejű CPS}

A vezérlési szerkezetek bemutatásakor egyik oldalon szerepelt a forráskód, a másik oldalon pedig az ebből képzett metódusok. A két oldal közötti mechanika nem került pontos ismertetésre. A transzformáció egzakt működése azonban csak ennek felfedésével lesz megérthető.

A technikát fordítási idejű \textit{CPS}-nek neveztem el. Az előző példákból kitűnik, hogy minden szerkezet metódusok egy sorára képezhető le. Viszont mi a teendő egymásba ágyazott szerkezetek vagy pedig ugró utasítások esetén? Mindig tudni kell, hogy a vezérlésnek hol kell folytatódnia, hogyan kell összekötni a már említett építőkockákat. A \textit{continuation} pontosan erre szolgál, a hátralevő számítás nyilvántartására, így fordítási időben is ez kerül alkalmazásra.

Az eljárás áttekinthető leírását adja, ha egy példán keresztül szemléljük a működését.

\begin{lstlisting}[language=Java, caption={Ugró utasítást tartalmazó generátormetódus}, captionpos=b, label=GenCompileTimeCPS, escapechar=$]
@Generator
Stream<Integer> generate() {
  for (int i = 0; i < 10; ++i) {
    if (i == 5) {
      break;
    }

    return i;
  }
}
\end{lstlisting}

A \ref{GenCompileTimeCPS} kódrészlet \texttt{for} ciklusában látható egy \texttt{break} utasítás, mely a feltétel teljesülése esetén a ciklusból való kilépést fogja okozni. Hogyan lehet megvalósítani ezt a működést? A transzformáció először megvizsgálja, hogy van-e a \texttt{for} ciklus belsejében \texttt{return}. Mivel van, ezért elkezdi felbontani a ciklust a \ref{GenFor} kódrészletben látottakhoz hasonló metódusokra. Mielőtt azonban ezt megtenné, elmenti, hogy a \texttt{for} ciklus befejezése után melyik metódusnak kell következnie. Ha még nincs ilyen, akkor létrehoz egy lezáró metódust. Amikor a ciklusfeltételt tartalmazó metódust hozza létre, abban ennek a megjegyzett metódusnak a hívását helyezi el. Így a transzformált ciklust és a meglevő metódusokat össszekötötte. Ez az elv jelenik meg a \texttt{break} esetén is. Amikor elkezdődik a \texttt{for} transzformációja, akkor elmentésre kerül, hogy egy \texttt{break} vagy egy \texttt{continue} melyik, már létrehozott metódusba irányítaná a vezérlést.

Egymásba ágyazott szerkezetek és címkék is megvalósíthatóak ezzel a módszerrel. Egy \textit{break-}, valamint \textit{continue-continuation} mindaddig érvényben marad, míg felülírásra nem kerül (például egy beágyazott ciklus által), vagy a transzformáció följebb nem lép a szintaxisfában. Amikor az eljárás egy címkézett utasítást talál, akkor pedig egy címkézett \textit{continuation}t alkalmazva tartja nyilván, hogyan kell majd a vezérlést szabályozni. Így a transzformáció eredményeként előálló kód már nem fog tartalmazni se címkéket, se ugró utasításokat, hiszen nincsen rájuk szükség. Ezek hatása is explicitté vált.

\section{Lokális változók és paraméterek kiemelése}

Az eredeti generátormetódus felbontásával a lokális változók felhasználásának helyei is különböző metódusokba kerülhetnek. Azért, hogy a működés a transzformáció után is biztosított legyen, át kell hidalni a metódusok közötti lyukakat. 

Egy lehetséges megoldás, hogy minden lokális változót kiemelünk a generátor számára létrehozott osztály egy mezőjébe. Ezzel egy csapásra megoldottuk a hatókörrel kapcsolatos gondokat. Viszont ügyelni kell arra, hogy az inicializációval egybekötött deklarációkat kicseréljük egy értékadásra. Ez azonban csak a kisebbik probléma. Azzal, hogy a változókat mindenhol hozzáférhető, mező szintre emeltük, a hatókörük túl széles lett.

A hatókör leszűkítésére nincs mód, így más megoldáshoz kell folyamodnunk. Csak akkor okoz problémát a túl széles hatókör, ha több, azonos nevű lokális változó került deklarálásra. Ilyenkor alapesetben ütköző nevű mezők jöhetnének létre. Ezt elkerülendő a már észlelt nevű lokális változók átnevezésre kerülnek.

\begin{lstlisting}[language=Java, caption={Elfedő deklarációkat tartalmazó generátor}, captionpos=b, label=GenShadowing, escapechar=$]
@Generator
Stream<Integer> generate() {
  {
    int i = 0;

    return i;
  }

  {
    int i = 2;

    class Clazz {
      int i = 1;

      int getValue() {
        return i;
      }
    }

     return new Clazz().getValue();
  }
}
\end{lstlisting}

Az átnevezés rekurzív módon történik, a tartalmazó blokk deklarációt követő utasításainak vizsgálatával. Bár a \textit{Java} nem teszi lehetővé lokális változók nevének elfedését, vannak olyan esetek, ahol az egyszerű rekurzív névcsere megváltoztatná a kód működését. Ezek a lokális és névtelen osztályok. A tartalmazó metódus lokális változói hozzáférhetőek ezekben az osztályokban, viszont deklarálható azonos nevű mező, vagy valamely metódusban lokális változó. Emiatt ilyen struktúrákban fokozott körültekintéssel kell elvégezni a névcserét.

A \ref{GenShadowing} kódrészlet hivatott szemléltetni a problémát. A forráskód negyedik és tizedik sorában található deklarációk kiemelése ütköző nevű mezőket eredményezne, így a második \texttt{i} változót át kell nevezni. Ez a tartalmazó blokk hátralevő utasításainak átvizsgálását, és az előfordulások átnevezését vonja maga után. Azonban a 12. sorban deklarált \texttt{Clazz} osztály szintén rendelkezik egy \texttt{i} mezővel, ami elfedi a tizedik sorban deklarált \texttt{i} változót. Ennek következtében az osztályon belül nem szabad névcseréket végezni. 

Az eredeti metódus paraméterei szintén mezők formájában állnak majd a generált metódusok rendelkezésére. Ezeknél biztosan nem kell az átnevezéssel foglalkozni, hiszen előttük nem áll deklaráció, mely azonos névvel rendelkezne.

\section{Befejező lépések}

Az előző műveletek után már csak néhány kisebb teendő maradt, melyek közül a legjelentősebb az eredeti generátormetódus átírása. Az eredeti implementációval egyenértékű generátort egy osztályba helyeztük el. Először ennek kell egy példányát létrehozni. Ezt követi a paraméterek számára létrehozott mezők inicializálása a metódus argumentumaival. Nem statikus metódus esetén a tartalmazó osztály aktuális példányára mutató referencia is átadásra kerül. Végül meg kell hívni az osztály generált \texttt{stream()} metódusát, mely elindítja a generátort. Ugyanez a metódus visszaad egy \texttt{Stream}et is, mely az új implementáció visszatérési értéke lesz.

A legutolsó lépés a \texttt{@Generator} annotáció eltávolítása a metódusról a többszöri transzformáció elkerülése végett.

\begin{lstlisting}[language=Java, caption={Az $1, 2$ sorozatot előállító generátor a transzformáció előtt}, captionpos=b, label=GenBefore, escapechar=$]
@Generator
Stream<Integer> generate() {
    return 1;
    return 2;
}
\end{lstlisting}

\begin{lstlisting}[language=Java, caption={Az $1, 2$ sorozatot előállító generátor a transzformáció után}, captionpos=b, label=GenAfter, escapechar=!]
Stream<Integer> generate() {                                                                                                    
    $GeneratorImpl_0generate581665465 $generator = new $GeneratorImpl_0generate581665465();                                   
    $generator.$Example1064910397 = this;                                                                                      
    return $generator.stream();                                                                                                 
}                                                                                                                               
                                                                                                                                
private final class $GeneratorImpl_0generate581665465 {                                                                        
    private Example $Example1064910397;                                                                                        
                                                                                                                                
    private Stream<Integer> stream() {                                                                                          
        return jield.runtime.BaseGenerator.startingAt(this::<>$generate_1014242157_0).stream();                                 
    }                                                                                                                           
                                                                                                                                
    private jield.runtime.Bounce<Integer> $generate_1014242157_0(jield.runtime.GeneratorState<java.lang.Integer> $_contParam) { 
        return jield.runtime.Bounce.cont(()->$generate_1014242157_2($_contParam), 1);                                           
    }                                                                                                                           
                                                                                                                                
    private jield.runtime.Bounce<Integer> $generate_1014242157_1(jield.runtime.GeneratorState<java.lang.Integer> $_contParam) { 
        return jield.runtime.Bounce.cont(()->$_contParam.apply(jield.runtime.GeneratorState.empty()));                          
    }                                                                                                                           
                                                                                                                                
    private jield.runtime.Bounce<Integer> $generate_1014242157_2(jield.runtime.GeneratorState<java.lang.Integer> $_contParam) { 
        return jield.runtime.Bounce.cont(()->$generate_1014242157_3($_contParam), 2);                                           
    }                                                                                                                           
                                                                                                                                
    private jield.runtime.Bounce<Integer> $generate_1014242157_3(jield.runtime.GeneratorState<java.lang.Integer> $_contParam) { 
        return jield.runtime.Bounce.cont(()->$generate_1014242157_1($_contParam));                                              
    }                                                                                                                           
                                                                                                                                
    private jield.runtime.Bounce<Integer> $generate_1014242157_4(jield.runtime.GeneratorState<java.lang.Integer> $_contParam) { 
        return jield.runtime.Bounce.cont(()->$generate_1014242157_1($_contParam));                                              
    }                                                                                                                           
}                                                                                                                               
\end{lstlisting}

A \ref{GenBefore} és \ref{GenAfter} kódrészletek szemléltetik a teljes transzformációs folyamat kezdő- és végpontját. Az újonnan létrehozott osztály átlátszatlan számsorozatokat tartalmaz a névütközések elkerülése érdekében. Az összes generátor között megosztott kódot, mint például a \textit{trampoline}, a \texttt{BaseGenerator} osztály tartalmazza, mely a \textit{Jield} futásidejű könyvtárának része.