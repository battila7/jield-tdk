\chapter{\textit{Continuation Passing Style} és kapcsolódó eszközök}

Az előző fejezet bevezette a generátorokat, melyeknek használatát lehetővé szeretnénk tenni \textit{Java}ban. Egyelőre azonban csak azt tudjuk, hogy \textit{mit} szeretnénk elérni, a \textit{hogyan} rejtve maradt. Felfedni ezt is csak lépésenként érdemes, továbbra is fokozatosan bevezetve a fogalmakat, melyekre a módszer támaszkodik. E fejezet a \textit{Continuation Passing Style} (továbbiakban \textit{CPS}), és néhány kapcsolódó eszköz ismertetését tartalmazza. Ezek birtokában már kifejezhetjük a dolgozat eredményét jelentő transzformációt és annak implementációját.

\section{\textit{Direct Style}}

A \textit{CPS} kifejtése előtt röviden vizsgáljuk meg ellentétét, a \textit{direct style}-t \cite{Danvy1994}, mely nem szorul hosszú bemutatásra, hiszen ez a programok írásának általánosan alkalmazott eszköze. Az ebben a stílusban írt függvények pusztán a formális paramétereiknek megfelelő argumentumokkal kerülnek meghívásra, futásuk befejeztét követően pedig visszatérnek a hívóhoz valamilyen értékkel (vagy bármilyen érték nélkül).

Friedman és Wand \citeyear{EssProgLan} gondolatmenetét követve, vegyük szemügyre a faktoriális kiszámítását végző különböző függvények viselkedését.

\begin{lstlisting}[language=JavaScript, caption={\textit{Direct style} faktoriálist meghatározó rekurzív függvény JavaScriptben}, captionpos=b, label=JSDSFactRec]
function factDSRec(n) {
    if (n === 0) {
        return 1;
    } else {
        return n * factDSRec(n - 1);
    }
}
\end{lstlisting}

A \ref{JSDSFactRec} kódrészlet egy rekurzív, \textit{direct style} függvény, mely \texttt{n} faktoriálisát határozza meg. A függvény működésének illusztrálásához vezessük le, hogyan kerül kiszámításra $4!$ értéke.

\begin{lstlisting}[language=JavaScript, caption={$4!$ kiszámítása \texttt{factDSRec} segítségével}, captionpos=b, numbers=none]
   factDSRec(4)
=  4 * factDSRec(3)
=  4 * (3 * factDSRec(2))
=  4 * (3 * (2 * factDSRec(1)))
=  4 * (3 * (2 * 1))
=  4 * (3 * 2)
=  4 * 6
=  24
\end{lstlisting}

Amíg a futás el nem éri a rekurzió alapesetét, új \texttt{factDSRec} hívások történnek, mindig eggyel kisebb \texttt{n} értékkel. Figyelemre méltó, hogy minden hívással együtt megjelenik egy szorzás is, mely csak a függvény visszatérését követően lesz elvégezhető.

\begin{lstlisting}[language=JavaScript, caption={\textit{Direct style} faktoriálist meghatározó függvény JavaScriptben}, captionpos=b, label=JSDSFactIter]
function factDSIter(n) {
    function factIterAcc(i, acc) {
        if (i === 0) {
            return acc;
        } else {
            factIterAcc(i - 1, acc * i);
        }
    }

    factIterAcc(n, 1);
}
\end{lstlisting}

A \ref{JSDSFactIter} kódrészlet két ponton különbözik jelentősen a \texttt{factDSRec} függvénytől. Az eltérések elemzését megelőzően azonban számoljuk ki ismét $4!$ értékét!

\begin{lstlisting}[language=JavaScript, caption={$4!$ kiszámítása \texttt{factDSIter} segítségével}, captionpos=b, numbers=none]
   factDSIter(4)
=  factIterAcc(4, 1)
=  factIterAcc(3, 4)
=  factIterAcc(2, 12)
=  factIterAcc(1, 24)
=  24
\end{lstlisting}

Az első, ami szembetűnik, hogy a számítás nem rendelkezik a \texttt{factDSRec} ``piramis'' mintájával, mely a sorozatos hívások által kijelölt szorzásoknak volt köszönhető. A rekurzív hívások ebben az esetben is jelen vannak, azonban az előző függvény \textit{hátralevő} szorzásait az \texttt{acc} paraméterbe helyeztük. Ennek következtében nem szükséges a kijelölt műveletek folyamatos feljegyzése, a függvény futásának tárigénye konstans. Ezt a működést, a rekurzió ellenére \textit{iterative control behaviour}nak nevezzük \shortcite{EssProgLan}.

\section{\textit{Continuation Passing Style}}

A \textit{CPS}-t az idők folyamán sokan sokféle formában felfedezték, és definiálták \cite{Reynolds1993}. Egy elegáns meghatározás a következő, mely pusztán két szabályt fektet le. A függvények

\begin{enumerate}
    \item sohasem térhetnek vissza, és
    \item formális paraméterlistájuk kiegészül egy \textit{continuation}nek nevezett paraméterrel \cite{MightCPS}.
\end{enumerate}

A stílus minden előnyös tulajdonsága a fenti szabályok alkalmazásának köszönhető. Viszont felmerülhet a kérdés, hogy ha egy függvény sohasem térhet vissza, akkor mégis hogyan képes értéket visszaadni? Sussman és Steele \citeyear{Sussman1975} erre a következő választ adja: ``\textit{\textellipsis in this continuation-passing programming style, a function always "returns" its result by "sending" it to another function}''. 

A függvény, aminek a visszatérési érték át lesz adva, nem más, mint a \textit{continuation}. Ez fogja jelképezni a még hátralevő számításokat, azaz hogy \textit{mi a teendő ezután} \cite{CompCont}.

\subsection{Példák \textit{CPS} függvényekre}

Amilyen egyszerű módon vezettük be a stílust, legalább annyira nehéz elképzelni, hogyan is működik. Ezért nézzünk két példát a \textit{CPS} alkalmazására!

\begin{lstlisting}[language=JavaScript, caption={\textit{CPS} összeadást végző függvény JavaScriptben}, captionpos=b, label=JSCPSAdd]
function addCPS(a, b, cont) {
    cont(a + b);
}

addCPS(10, 20, function print(n) {
    console.log(n);
});
\end{lstlisting}

A \ref{JSCPSAdd} kódrészlet először egy \texttt{addCPS} nevű függvényt definiál, melynek \textit{direct style} esetén csak két paramétere lenne, az összeadandó értékek. A második szabály értelmében azonban hozzá kellett adni egy harmadik paramétert is. Ez lesz a \textit{continuation}, aminek át kell adnunk az összeadás eredményét, hiszen az első szabály megtiltja, hogy a függvény visszatérjen vele. Ezután a függvény meghívásának módja már egyértelmű. Átadunk egy függvényt, mely paraméterül várja a kiszámított értéket, és tesz vele valamit, jelen esetben kiírja a konzolra.

Következzen egy összetettebb példa, a \texttt{factDSRec} függvény \textit{CPS}-transzformációja!

\begin{lstlisting}[language=JavaScript, caption={\textit{CPS} faktoriálist kiszámító függvény JavaScriptben}, captionpos=b, label=JSCPSFact]
function factCPS(n, cont) {
    if (n === 0) {
        cont(1);
    } else {
        factCPS(n - 1, val => cont(n * val));
    }
}
\end{lstlisting}

Mire érdemes felfigyelni a függvény törzsében? Természetesen a \texttt{return} utasítások eltűntek, helyükre viszont annál érdekesebb kifejezések kerültek. A \texttt{return 1;} utasítást felváltotta a konstans érték átadása a \textit{continuation}nek, hasonlóan az \texttt{addCPS} függvényhez. Az eredeti \texttt{factDSRec} függvény ötödik sorának helyén álló hívás viszont már nem ilyen magától értetődő. Könnyebben követhetővé válik a transzformáció, ha beiktatunk egy közbülső lépést.

\lstset{language=JavaScript, numbers=none, breaklines=true}

\begin{table}[h]
\captionsetup{justification=centering}
\centering
\begin{tabular}{p{0.33\linewidth} | p{0.33\linewidth} | p{0.33\linewidth}}
\begin{lstlisting}
return
    n * factDSRec(n - 1);
\end{lstlisting}&
\begin{lstlisting}
const val =
    factDSRec(n - 1);

return n * val;
\end{lstlisting}&
\begin{lstlisting}
factCPS(n - 1, 
 val => cont(n * val));
\end{lstlisting} 
\end{tabular}
\caption{A \texttt{return} utasítás transzformálásának lépései a \texttt{factDSRec} függvényben}  
\label{table:steps}
\end{table}

% reset lstset
\lstset{xleftmargin=15pt,
        basicstyle=\scriptsize,
        numbers=left,
        numbersep=5pt,
        numberstyle=\tiny\color{codegray},
        escapechar=@,
        aboveskip=2em,
        belowskip=2em,
        belowcaptionskip=2em}

A középső lépésben egy nevet rendelünk az eredetileg rekurzív függvényhívás eredményéhez, ezzel explicitté téve azt, hogy a szorzás elvégzése előtt egy függvényhívást kell végrehajtani. Pontosan ez jelenik meg a jobboldalon is. Meghívjuk a \texttt{factCPS} függvényt, az eredeti \textit{continuation} helyett egy új függvénnyel, melyben elvégezzük a szorzást. Utána a szorzás eredménye már továbbadható a kapott \textit{continuation}nek.

Az \texttt{addCPS} és a \texttt{factDSRec} függvény transzformációjának lépései valójában néhány szabályban összefoglalhatóak és általánosíthatóak. Egy ilyen transzformációs ``\textit{receptet}'' ad meg Friedman \citeyear{EssProgLan}.

\subsection{Programvezérlés \textit{CPS} segítségével}
